#' Add Unique Subject ID to Stacked Pairs
#'
#' @description Function that assigns a potential Unique Subject ID to
#'              stacked pairs, revealing groups wherein pairs potentially
#'              overlap. This facilitates manual review of matches. 
#'              Modified from the original version written by Dr. MBC.
#'   
#'   Dependencies: dplyr
#'   
#'   Built: R (4.4.1); dplyr (1.1.4)
#'
#' @param dfA_pack A list containing the following named arguments for
#'                 data frame A in the fastLink fuzzy matching: 
#'                 $df (the original data frame A); $ids (list of identifiers
#'                 for data frame A, with a row-unique ID first); 
#'                 $suffix (a suffix to specify that a row came from 
#'                 data frame A, when reviewing stacked pairs) 
#' @param dfB_pack A list containing the following named arguments for
#'                 data frame B in the fastLink fuzzy matching: 
#'                 $df (the original data frame B); $ids (list of identifiers
#'                 for data frame B, with a row-unique ID first); 
#'                 $suffix (a suffix to specify that a row came from 
#'                 data frame B, when reviewing stacked pairs) 
#' @param paired_matches A data frame of stacked pairs, generated by the
#'                       get_pair_data() function.
#'
#' @return The "paired_matches" data frame, with a unique subject ID
#'         that may be used to consolidate or separate groups into unique
#'         subjects through manual reivew.
#' @export
#'

stack_ids <- function(dfA_pack, dfB_pack, paired_matches){
  
  # If dfA_pack and dfB_pack are identical, add "a" and "b" to ID suffixes
  if (identical(dfA_pack, dfB_pack)){
    
    dfA_id <- paste(dfA_pack$ids[1], "a", sep = "_")
    dfB_id <- paste(dfB_pack$ids[1], "b", sep = "_")
    
  }
  # Otherwise, just use their packed suffixes
  if (!identical(dfA_pack, dfB_pack)){
    dfA_id <- paste(dfA_pack$ids[1], dfA_pack$suffix, sep = "_")
    dfB_id <- paste(dfB_pack$ids[1], dfB_pack$suffix, sep = "_")
  }
  
  id_vars <- c(dfA_id, dfB_id)
  
  # Turn fastLink results into tibble of rows and their matches
  matches <- paired_matches |>
    dplyr::select(all_of(id_vars))
  
  colnames(matches) <- c("dfA_row", "dfB_row")
  
  # Nest all matches for each row
  matches <- matches |> 
    dplyr::group_by(dfB_row) |> 
    dplyr::mutate(AmatchesB = list(dfA_row)) |>
    dplyr::ungroup() |>
    dplyr::group_by(dfA_row) |>
    dplyr::mutate(BmatchesA = list(dfB_row)) |>
    dplyr::ungroup()
  
  # Process slightly differently if identical input data frames
  if (identical(dfA_pack, dfB_pack)) {
    
    # Reduce to unique sets of matching rows
    # i.e. 1,2,3 is the same as 3,2,1
    matches <- matches |>
      dplyr::rowwise() |>
      dplyr::mutate(match_rows = list(unique(c(AmatchesB, BmatchesA)))) |> 
      dplyr::ungroup() |>
      dplyr::mutate(match_rows = purrr::map_chr(
        match_rows,
        function(x) {
          x = sort(x) # 1,2,3 is the same as 3,2,1
          x = paste(x, collapse = ",") # Convert list to character string
          x
        })
      ) |>
      dplyr::select(match_rows) |>
      dplyr::distinct() # Reduce to 1 row per group of matches
    
    
    # Sequentially number each group of matches
    # This will become the unique id
    matches <- matches |>
      dplyr::mutate(
        id = dplyr::row_number(),
        dfA_row = purrr::map( # Turn back into list
          match_rows,
          ~ scan(text = ., what = 0L, sep = ",", quiet = TRUE)
        )
      ) |>
      # Unnest the list into multiple rows
      tidyr::unnest(dfA_row)
    
    # Join the unique ID into the primary subset data set for review
    
    out <- matches |>
      dplyr::right_join(
        dfA_pack$df,
        by = c('dfA_row'=dfA_pack$ids[1])
      ) 
    
    colnames(out)[3] <- dfA_pack$ids[1]
  }
  
  # Otherwise use Dr. Cannell's initial processing with slight modification
  if (!identical(dfA_pack, dfB_pack)) {
    
    # Reduce to unique sets of matching rows
    # i.e. 1,2,3 is the same as 3,2,1
    matches <- matches |> 
      dplyr::mutate(dfA_matchesB = purrr::map_chr(
        AmatchesB,
        function(x) {
          x = sort(x) # 1,2,3 is the same as 3,2,1
          x = paste(x, collapse = ",") # Convert list to character string
          x
        })
      ) |> 
      dplyr::mutate(dfB_matchesA = purrr::map_chr(
        BmatchesA,
        function(x) {
          x = sort(x) # 1,2,3 is the same as 3,2,1
          x = paste(x, collapse = ",") # Convert list to character string
          x
        })
      ) |> 
      dplyr::select(dfA_matchesB, dfB_matchesA) |>
      dplyr::distinct() # Reduce to 1 row per group of matches
    
    
    # Sequentially number each group of matches
    # This will become the unique id
    matches <- matches |>
      dplyr::mutate(
        id = dplyr::row_number(),
        dfA_row = purrr::map( # Turn back into list
          dfA_matchesB,
          ~ scan(text = ., what = 0L, sep = ",", quiet = TRUE)
        ),
        dfB_row = purrr::map( # Turn back into list
          dfB_matchesA,
          ~ scan(text = ., what = 0L, sep = ",", quiet = TRUE)
        )
      )
    
    # Covert to data frame with the appropriate id number for each
    # unique observation id combination from dfA and dfB
    
    matches <- matches |>
      tidyr::unnest(cols=c(dfA_row)) |>
      tidyr::unnest(cols=c(dfB_row)) |>
      dplyr::select(id, dfA_row, dfB_row)
    
    # Join the unique ID into the paired matches set for review, based on
    # the dfA unique observation ID
    
    out <- matches |>
      dplyr::right_join(
        paired_matches,
        by = c('dfA_row'=dfA_id, 'dfB_row'=dfB_id)
      )
    
    colnames(out)[2:3] <- id_vars
  }
  
  # Return revised paired matches with pair ID
  out
}